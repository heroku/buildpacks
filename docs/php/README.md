<!-- STOP
  This file was generated by a rundoc script, do not modify it.

  Instead modify the rundoc script and re-run it.

  Command: /home/runner/work/buildpacks/buildpacks/vendor/bundle/ruby/3.3.0/bin/rundoc docs/src/php/RUNDOC.md
STOP -->

# Heroku PHP Cloud Native Buildpack (CNB) Tutorial

Build a Slim PHP application image in 5 minutes, no Dockerfile required.

At the end of this tutorial, you'll have a working [OCI image](https://opencontainers.org/) of a Slim PHP application that can run locally. You will learn about the Cloud Native Buildpack (CNB) ecosystem, and how to utilize the [pack CLI](https://buildpacks.io/docs/for-platform-operators/how-to/integrate-ci/pack/) to build images without the need to write or maintain a Dockerfile.

> You can now also use the `heroku/php` CNB on Heroku [Fir generation](https://devcenter.heroku.com/articles/generations#fir) via the [pilot program](https://hello.heroku.com/next-generation-sign-up). See the [Getting started on Heroku Fir Dev Center tutorial](https://devcenter.heroku.com/articles/getting-started-with-php-fir).

<!-- space -->
## Install the pack CLI

We assume you have [docker installed](https://docs.docker.com/engine/install/) and a working copy [of git](https://github.com/git-guides/install-git). Next, you will need to install the CLI tool for building CNBs, [pack CLI](https://buildpacks.io/docs/for-platform-operators/how-to/integrate-ci/pack/). If you're on a Mac you can install it via Homebrew:

```
$ brew install buildpacks/tap/pack
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Ensure that `pack` is installed correctly:

```
$ pack --version
0.37.0+git-bf1bd85.build-6370
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->
## Configure the default pack builder

Once `pack` is installed, the only configuration you'll need for this tutorial is to set a default builder:

```
$ pack config default-builder heroku/builder:24
Builder 'heroku/builder:24' is now the default builder
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

You can view your default builder at any time:

```
$ pack config default-builder
The current default builder is 'heroku/builder:24'
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

> Note: The `heroku/builder:24` supports both amd64 (also known as x86) and arm64 (such as aarch64 used with newer Mac machines) architectures. If needed, you can configure the architecture for `docker` and `pack` CLIs using the `--platform` argument if needed. For example `--platform linux/amd64`.
## What is a builder?

> [!NOTE]
> Skip ahead if you want to build the application first and get into the details later. You won't need to
> know about builders for the rest of this tutorial.

In short, a builder is a delivery mechanism for buildpacks. A builder contains references to base images and individual buildpacks. A base image contains the operating system and system dependencies. Buildpacks are the components that will configure an image to run your application, that’s where the bulk of the logic lives and why the project is called “Cloud Native Buildpacks” and not “Cloud Native Builders.”

You can view the contents of a builder via the command `pack builder inspect`. For example:

```
$ pack builder inspect heroku/builder:24 | awk '/^Buildpacks:/ {flag=1} /^Detection Order:/ {exit} flag'
Buildpacks:
  ID                                NAME                               VERSION        HOMEPAGE
  heroku/deb-packages               Heroku .deb Packages               0.1.3          https://github.com/heroku/buildpacks-deb-packages
  heroku/dotnet                     Heroku .NET                        0.5.0          https://github.com/heroku/buildpacks-dotnet
  heroku/go                         Heroku Go                          1.0.0          https://github.com/heroku/buildpacks-go
  heroku/gradle                     Heroku Gradle                      6.2.1          https://github.com/heroku/buildpacks-jvm
  heroku/java                       Heroku Java                        6.2.1          https://github.com/heroku/buildpacks-jvm
  heroku/jvm                        Heroku OpenJDK                     6.2.1          https://github.com/heroku/buildpacks-jvm
  heroku/maven                      Heroku Maven                       6.2.1          https://github.com/heroku/buildpacks-jvm
  heroku/nodejs                     Heroku Node.js                     3.6.1          https://github.com/heroku/buildpacks-nodejs
  heroku/nodejs-corepack            Heroku Node.js Corepack            3.6.1          https://github.com/heroku/buildpacks-nodejs
  heroku/nodejs-engine              Heroku Node.js Engine              3.6.1          https://github.com/heroku/buildpacks-nodejs
  heroku/nodejs-npm-engine          Heroku Node.js npm Engine          3.6.1          https://github.com/heroku/buildpacks-nodejs
  heroku/nodejs-npm-install         Heroku Node.js npm Install         3.6.1          https://github.com/heroku/buildpacks-nodejs
  heroku/nodejs-pnpm-engine         Heroku Node.js pnpm Engine         3.6.1          https://github.com/heroku/buildpacks-nodejs
  heroku/nodejs-pnpm-install        Heroku Node.js pnpm Install        3.6.1          https://github.com/heroku/buildpacks-nodejs
  heroku/nodejs-yarn                Heroku Node.js Yarn                3.6.1          https://github.com/heroku/buildpacks-nodejs
  heroku/php                        Heroku PHP                         1.0.1          https://github.com/heroku/buildpacks-php
  heroku/procfile                   Heroku Procfile                    4.2.1          https://github.com/heroku/buildpacks-procfile
  heroku/python                     Heroku Python                      1.0.0          https://github.com/heroku/buildpacks-python
  heroku/ruby                       Heroku Ruby                        7.0.1          https://github.com/heroku/buildpacks-ruby
  heroku/sbt                        Heroku sbt                         6.2.1          https://github.com/heroku/buildpacks-jvm
  heroku/scala                      Heroku Scala                       6.2.1          https://github.com/heroku/buildpacks-jvm
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

> [!NOTE]
> Your output version numbers may differ.

This output shows the various buildpacks that represent the different languages that are supported by this builder such as `heroku/go` and `heroku/nodejs-engine`.
## Download an example Slim PHP application

How do you configure a CNB? Give them an application. While Dockerfile is procedural, buildpacks, are declarative. A buildpack will determine what your application needs to function by inspecting the code on disk.

For this example, we're using a pre-built Slim PHP application. Download it now:

```
$ git clone https://github.com/heroku/php-getting-started
$ cd php-getting-started
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Verify you're in the correct directory:

```
$ ls -A
.git
.github
.gitignore
Procfile
README.md
app.json
composer.json
composer.lock
views
web
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

This tutorial was built using the following commit SHA:

```
$ git log --oneline | head -n1
0f5b762 Update repo metadata (#84)
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->
## Build the application image with the pack CLI

Now build an image named `my-image-name` by executing the heroku builder against the application by running the
`pack build` command:

```
$ pack build my-image-name --path .
===> ANALYZING
Image with name "my-image-name" not found
===> DETECTING
2 of 3 buildpacks participating
heroku/php      1.0.1
heroku/procfile 4.2.1
===> RESTORING
Skipping buildpack layer analysis
===> BUILDING

## Heroku PHP Buildpack

- Bootstrapping
- Preparing platform packages installation
- Installing platform packages
  - Running `composer install --no-dev --no-interaction`

      No composer.lock file present. Updating dependencies to latest instead of installing from lock file. See https://getcomposer.org/install for more information.
      Loading composer repositories with package information
      Updating dependencies
      Lock file operations: 26 installs, 0 updates, 0 removals
        - Locking fig/http-message-util (1.1.5)
        - Locking heroku-sys/composer (2.8.2)
        - Locking heroku-sys/php (8.3.13)
        - Locking heroku/installer-plugin (1.8.0)
        - Locking laravel/serializable-closure (v1.3.7)
        - Locking monolog/monolog (3.8.0)
        - Locking nikic/fast-route (v1.3.0)
        - Locking php-di/invoker (2.3.4)
        - Locking php-di/php-di (7.0.7)
        - Locking php-di/slim-bridge (3.4.1)
        - Locking psr/container (2.0.2)
        - Locking psr/http-factory (1.1.0)
        - Locking psr/http-message (2.0)
        - Locking psr/http-server-handler (1.0.2)
        - Locking psr/http-server-middleware (1.0.2)
        - Locking psr/log (3.0.2)
        - Locking ralouphie/getallheaders (3.0.3)
        - Locking slim/psr7 (1.7.0)
        - Locking slim/slim (4.14.0)
        - Locking slim/twig-view (3.4.1)
        - Locking symfony/deprecation-contracts (v3.5.1)
        - Locking symfony/polyfill-ctype (v1.31.0)
        - Locking symfony/polyfill-mbstring (v1.31.0)
        - Locking symfony/polyfill-php80 (v1.31.0)
        - Locking symfony/polyfill-php81 (v1.31.0)
        - Locking twig/twig (v3.16.0)
      Writing lock file
      Installing dependencies from lock file
      Package operations: 26 installs, 0 updates, 0 removals
        - Installing heroku/installer-plugin (1.8.0): Mirroring from /layers/heroku_php/bootstrap_installer/support/installer
        - Downloading heroku-sys/php (8.3.13)
        - Downloading heroku-sys/composer (2.8.2)
       0/2 [>---------------------------]   0%
       1/2 [==============>-------------]  50%
       2/2 [============================] 100%
        - Installing heroku-sys/php (8.3.13)
        - Installing fig/http-message-util (1.1.5)
        - Installing heroku-sys/composer (2.8.2)
        - Installing laravel/serializable-closure (v1.3.7)
        - Installing monolog/monolog (3.8.0)
        - Installing nikic/fast-route (v1.3.0)
        - Installing php-di/invoker (2.3.4)
        - Installing php-di/php-di (7.0.7)
        - Installing php-di/slim-bridge (3.4.1)
        - Installing psr/container (2.0.2)
        - Installing psr/http-factory (1.1.0)
        - Installing psr/http-message (2.0)
        - Installing psr/http-server-handler (1.0.2)
        - Installing psr/http-server-middleware (1.0.2)
        - Installing psr/log (3.0.2)
        - Installing ralouphie/getallheaders (3.0.3)
        - Installing slim/psr7 (1.7.0)
        - Installing slim/slim (4.14.0)
        - Installing slim/twig-view (3.4.1)
        - Installing symfony/deprecation-contracts (v3.5.1)
        - Installing symfony/polyfill-ctype (v1.31.0)
        - Installing symfony/polyfill-mbstring (v1.31.0)
        - Installing symfony/polyfill-php80 (v1.31.0)
        - Installing symfony/polyfill-php81 (v1.31.0)
        - Installing twig/twig (v3.16.0)
          0 [>---------------------------]    0 [->--------------------------]
      Generating autoload files

  - Done (1.7s)
- Installing web servers
  - Running `composer install --no-dev --no-interaction`

      No composer.lock file present. Updating dependencies to latest instead of installing from lock file. See https://getcomposer.org/install for more information.
      Loading composer repositories with package information
      Updating dependencies
      Lock file operations: 4 installs, 0 updates, 0 removals
        - Locking heroku-sys/apache (2.4.62)
        - Locking heroku-sys/nginx (1.26.2)
        - Locking heroku/heroku-buildpack-php (dev-bundled)
        - Locking heroku/installer-plugin (1.8.0)
      Writing lock file
      Installing dependencies from lock file
      Package operations: 4 installs, 0 updates, 0 removals
        - Installing heroku/installer-plugin (1.8.0): Mirroring from /layers/heroku_php/bootstrap_installer/support/installer
        - Downloading heroku-sys/apache (2.4.62)
        - Downloading heroku-sys/nginx (1.26.2)
       0/2 [>---------------------------]   0%
       2/2 [============================] 100%
        - Installing heroku-sys/apache (2.4.62)
        - Installing heroku-sys/nginx (1.26.2)
        - Installing heroku/heroku-buildpack-php (dev-bundled): Mirroring from /layers/heroku_php/bootstrap_installer
          0 [>---------------------------]    0 [->--------------------------]
      Generating autoload files

  - Done (1.0s)
- Installing dependencies
  - Running `composer install -vv --no-dev --no-progress --no-interaction --optimize-autoloader --prefer-dist`

      Installing dependencies from lock file
      Verifying lock file contents can be installed on current platform.
      Dependency resolution completed in 0.000 seconds
      Package operations: 23 installs, 0 updates, 0 removals
      Installs: laravel/serializable-closure:v1.3.7, psr/log:3.0.2, monolog/monolog:3.8.0, nikic/fast-route:v1.3.0, psr/http-message:2.0, psr/http-server-handler:1.0.2, psr/http-server-middleware:1.0.2, psr/http-factory:1.1.0, psr/container:2.0.2, slim/slim:4.14.0, php-di/invoker:2.3.4, php-di/php-di:7.0.7, php-di/slim-bridge:3.4.1, symfony/polyfill-php80:v1.31.0, ralouphie/getallheaders:3.0.3, fig/http-message-util:1.1.5, slim/psr7:1.7.0, symfony/polyfill-php81:v1.31.0, symfony/polyfill-mbstring:v1.31.0, symfony/polyfill-ctype:v1.31.0, symfony/deprecation-contracts:v3.5.1, twig/twig:v3.16.0, slim/twig-view:3.4.1
        - Downloading laravel/serializable-closure (v1.3.7)
        - Downloading psr/log (3.0.2)
        - Downloading monolog/monolog (3.8.0)
        - Downloading nikic/fast-route (v1.3.0)
        - Downloading psr/http-message (2.0)
        - Downloading psr/http-server-handler (1.0.2)
        - Downloading psr/http-server-middleware (1.0.2)
        - Downloading psr/http-factory (1.1.0)
        - Downloading psr/container (2.0.2)
        - Downloading slim/slim (4.14.0)
        - Downloading php-di/invoker (2.3.4)
        - Downloading php-di/php-di (7.0.7)
        - Downloading php-di/slim-bridge (3.4.1)
        - Downloading symfony/polyfill-php80 (v1.31.0)
        - Downloading ralouphie/getallheaders (3.0.3)
        - Downloading fig/http-message-util (1.1.5)
        - Downloading slim/psr7 (1.7.0)
        - Downloading symfony/polyfill-php81 (v1.31.0)
        - Downloading symfony/polyfill-mbstring (v1.31.0)
        - Downloading symfony/polyfill-ctype (v1.31.0)
        - Downloading symfony/deprecation-contracts (v3.5.1)
        - Downloading twig/twig (v3.16.0)
        - Downloading slim/twig-view (3.4.1)
        - Installing laravel/serializable-closure (v1.3.7): Extracting archive
        - Installing psr/log (3.0.2): Extracting archive
        - Installing monolog/monolog (3.8.0): Extracting archive
        - Installing nikic/fast-route (v1.3.0): Extracting archive
        - Installing psr/http-message (2.0): Extracting archive
        - Installing psr/http-server-handler (1.0.2): Extracting archive
        - Installing psr/http-server-middleware (1.0.2): Extracting archive
        - Installing psr/http-factory (1.1.0): Extracting archive
        - Installing psr/container (2.0.2): Extracting archive
        - Installing slim/slim (4.14.0): Extracting archive
        - Installing php-di/invoker (2.3.4): Extracting archive
        - Installing php-di/php-di (7.0.7): Extracting archive
        - Installing php-di/slim-bridge (3.4.1): Extracting archive
        - Installing symfony/polyfill-php80 (v1.31.0): Extracting archive
        - Installing ralouphie/getallheaders (3.0.3): Extracting archive
        - Installing fig/http-message-util (1.1.5): Extracting archive
        - Installing slim/psr7 (1.7.0): Extracting archive
        - Installing symfony/polyfill-php81 (v1.31.0): Extracting archive
        - Installing symfony/polyfill-mbstring (v1.31.0): Extracting archive
        - Installing symfony/polyfill-ctype (v1.31.0): Extracting archive
        - Installing symfony/deprecation-contracts (v3.5.1): Extracting archive
        - Installing twig/twig (v3.16.0): Extracting archive
        - Installing slim/twig-view (3.4.1): Extracting archive
      Generating optimized autoload files
      10 packages you are using are looking for funding.
      Use the `composer fund` command to find out more!

  - Done (1.8s)
- Preparing Composer runtime environment
  - Running `composer config --no-plugins bin-dir` ... (< 0.1s)
- Done (finished in 6.4s)

## Procfile Buildpack

- Processes from `Procfile`
  - web: `heroku-php-apache2 web/`
- Done (finished in < 0.1s)
===> EXPORTING
Adding layer 'heroku/php:composer_env'
Adding layer 'heroku/php:platform'
Adding layer 'heroku/php:webservers'
Adding layer 'buildpacksio/lifecycle:launch.sbom'
Added 1/1 app layer(s)
Adding layer 'buildpacksio/lifecycle:launcher'
Adding layer 'buildpacksio/lifecycle:config'
Adding layer 'buildpacksio/lifecycle:process-types'
Adding label 'io.buildpacks.lifecycle.metadata'
Adding label 'io.buildpacks.build.metadata'
Adding label 'io.buildpacks.project.metadata'
Setting default process type 'web'
Saving my-image-name...
*** Images (0793b60c5c45):
      my-image-name
Adding cache layer 'heroku/php:composer_cache'
Adding cache layer 'heroku/php:platform_cache'
Successfully built image 'my-image-name'
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

> [!NOTE]
> Your output may differ.

Verify that you see “Successfully built image my-image-name” at the end of the output. And verify that the image is present locally:

```
$ docker image ls --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}" | grep my-image-name
0793b60c5c45   my-image-name    latest
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->
## What does `pack build` do?

> [!NOTE]
> Skip ahead if you want to run the application first and get into the details later.

When you run `pack build` with a builder, each buildpack runs a detection script to determine if it should be eligible to build the application. In our case the `heroku/php` buildpack found a `composer.json` file. As a result, the buildpack has enough information to install PHP dependencies. You can view a list of the buildpacks used in the build output:


```
===> DETECTING
2 of 3 buildpacks participating
heroku/php      1.0.1
heroku/procfile 4.2.1
===> RESTORING
Skipping buildpack layer analysis
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

After the detect phase, each buildpack will execute. Buildpacks can inspect your project, install files to disk, run commands, write environment variables, [and more](https://buildpacks.io/docs/for-buildpack-authors/). You can see some examples of that in the output above. For example, the PHP buildpack installs dependencies from the `composer.json` automatically:

```
  - Running `composer install -vv --no-dev --no-progress --no-interaction --optimize-autoloader --prefer-dist`
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

If you’re familiar with Dockerfile you might know that [many commands in a Dockerfile will create a layer](https://dockerlabs.collabnix.com/beginners/dockerfile/Layering-Dockerfile.html). Buildpacks also use layers, but the CNB buildpack API provides for fine grained control over what exactly is in these layers and how they’re composed. Unlike Dockerfile, all images produced by CNBs [can be rebased](https://tag-env-sustainability.cncf.io/blog/2023-12-reduce-reuse-rebase-buildpacks/#reduce-reuserebase). The CNB api also improves on many of the pitfalls outlined in the satirical article [Write a Good Dockerfile in 19 'Easy' Steps](https://jkutner.github.io/2021/04/26/write-good-dockerfile.html).
## Use the image

Even though we used `pack` and CNBs to build our image, it can be run with your favorite tools like any other OCI image. We will be using the `docker` command line to run our image.

By default, images will be booted into a web server configuration. You can launch the app we just built by running:

```
$ docker run -it --rm --env PORT=5006 -p 5006:5006 my-image-name
DOCUMENT_ROOT changed to 'web/'
Assuming RAM to be 512M Bytes
Available RAM is 512M Bytes
Number of CPU cores is 4
PHP memory_limit is 128M Bytes
Calculated number of workers based on RAM and CPU cores is 16
Maximum number of workers that fit available RAM at memory_limit is 4
Limiting number of workers to 4
Starting php-fpm with 4 workers...
Starting httpd...
Application ready for connections on port 5006.
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now when you visit [http://localhost:5006](http://localhost:5006) you should see a working web application:

![Screenshot of http://localhost:5006/](screenshots/screenshot_1.png)

Don't forget to stop the docker container when you're done.


Here's a quick breakdown of that command we just ran:

- `docker run` Create and run a new container from an image.
- `-it` Makes the container interactive and allocates a TTY.
- `--rm` Automatically remove the container when it exits.
- `--env PORT=5006` Creates an environment variable named `PORT` and sets it to `5006` this is needed so the application inside the container knows what port to bind the web server.
- `-p 5006:5006` Publishes a container's port(s) to the host. This is what allows requests from your machine to be received by the container.
- `my-image-name` The name of the image you want to use for the application.

So far, we've downloaded an application via git and run a single command `pack build` to generate an image, and then we can use that image as if it was generated via a Dockerfile via the `docker run` command.

In addition to running the image as a web server, you can access the container's terminal interactively. In a new terminal window try running this command:

```
$ docker run -it --rm my-image-name bash
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Now you can inspect the container interactively. For example, you can see the files on disk with `ls`:

```
$ ls -A
.git
.github
.gitignore
Procfile
README.md
app.json
build_output.txt
composer.json
composer.lock
vendor
views
web
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

And anything else you would typically do via an interactive container session.
## Image structure under the hood

> [!NOTE]
> Skip this section if you want to try building your application with CNBs and learn about container structure later.

If you’re an advanced `Dockerfile` user you might be interested in learning more about the internal structure of the image on disk. You can access the image disk interactively by using the `bash` docker command above.

If you view the root directory `/` you’ll see there is a `layers` folder. Every buildpack that executes gets a unique folder:

```
$ docker run --rm my-image-name "ls /layers"
config
heroku_php
sbom
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

Individual buildpacks can compose multiple layers from their buildpack directory. For example you can see that `php` binary is present within that buildpack layer directory:

```
$ docker run --rm my-image-name "which php"
/layers/heroku_php/platform/bin/php
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

OCI images are represented as sequential modifications to disk. By scoping buildpack disk modifications to their own directory, the CNB API guarantees that changes to a layer in one buildpack will not affect the contents of disk to another layer. This means that OCI images produced by CNBs are rebaseable by default, while those produced by Dockerfile are not.

We saw before how the image booted a web server by default. This is accomplished using an entrypoint. In another terminal outside of the running container you can view that entrypoint:

```
$ docker inspect my-image-name | grep '"Entrypoint": \[' -A2
            "Entrypoint": [
                "/cnb/process/web"
            ],
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

From within the image, you can see that file on disk:

```
$ docker run --rm my-image-name "ls /cnb/process/"
web
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

While you might not need this level of detail to build and run an application with Cloud Native Buildpacks, it is useful to understand how they’re structured if you ever want to write your own buildpack.
## Try CNBs out on your application

So far we've learned that CNBs are a declarative interface for producing OCI images (like docker). They aim to be no to low configuration and once built, you can interact with them like any other image.

For the next step, we encourage you to try running `pack` with the Heroku builder against your application and let us know how it went. We encourage you to share your experience by [opening a discussion](https://github.com/heroku/buildpacks/discussions) and walking us through what happened:

- What went well?
- What could be better?
- Do you have any questions?

We are actively working on our Cloud Native Buildpacks and want to hear about your experience. The documentation below covers some intermediate-level topics that you might find helpful.
## Configuring your web process with the Procfile

Most buildpacks rely on existing community standards to allow you to configure your application declaratively. They can also implement custom logic based on file contents on disk or environment variables present at build time.

The `Procfile` is a configuration file format that was [introduced by Heroku in 2011](https://devcenter.heroku.com/articles/procfile), you can now use this behavior on your CNB-powered application via the `heroku/procfile`, which like the rest of the buildpacks in our builder [is open source](https://github.com/heroku/buildpacks-procfile). The `heroku/procfile` buildpack allows you to configure your web startup process.

This is the `web` entry in the getting started guide's `Procfile`:

```
web: heroku-php-apache2 web/
```
<!-- STOP. This document is autogenerated. Do not manually modify. See the top of the doc for more details. -->

By including this file and using `heroku/procfile` buildpack, your application will receive a default web process. You can configure this behavior by changing the contents of that file.

